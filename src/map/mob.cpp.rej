diff a/src/map/mob.cpp b/src/map/mob.cpp	(rejected hunks)
@@ -5 +4,0 @@
-
@@ -11 +9,0 @@
-#include <vector>
@@ -22 +19,0 @@
-#include "../common/timer.hpp"
@@ -91 +88,122 @@ MobChatDatabase mob_chat_db;
-MobExtendedAiConditionsDatabase mob_extended_ai_conditions_db;
+MobExpandedAiConditionsDatabase mob_expanded_ai_conditions_db;
+
+
+//Globals used by ai functions
+const std::unordered_map<std::string, sc_type> um_statusname2id{ // Subset used for mob ai
+   {	"anybad",				SC_NONE				},
+   {	"stone",				SC_STONE			},
+   {	"freeze",				SC_FREEZE			},
+   {	"stun",					SC_STUN				},
+   {	"sleep",				SC_SLEEP			},
+   {	"poison",				SC_POISON			},
+   {	"curse",				SC_CURSE			},
+   {	"silence",				SC_SILENCE			},
+   {	"confusion",			SC_CONFUSION		},
+   {	"blind",				SC_BLIND			},
+   {	"decreaseagi",				SC_DECREASEAGI		},
+   {	"hiding",				SC_HIDING			},
+   {	"cloaking",				SC_CLOAKING			},
+   {	"edp",					SC_EDP				},
+   {	"ruwach",				SC_RUWACH			},
+   {	"sight",				SC_SIGHT			},
+   {	"blessing",				SC_BLESSING			},
+   {	"increaseagi",			SC_INCREASEAGI		},
+   {	"assumptio",			SC_ASSUMPTIO  		},
+   {	"kyrie",				SC_KYRIE,			},
+   {	"magnificat",			SC_MAGNIFICAT,		},
+   {	"safetywall",			SC_SAFETYWALL 		},
+   {	"pneuma",				SC_PNEUMA			},
+   {	"explosionspirits",		SC_EXPLOSIONSPIRITS	},
+   {	"doublecasting",		SC_DOUBLECAST		},
+   {	"volcano",				SC_VOLCANO			},
+   {	"amplify",				SC_MAGICPOWER		},
+   {	"quagmire",				SC_QUAGMIRE			},
+   {	"spiderweb",			SC_SPIDERWEB		},
+   {	"energycoat",			SC_ENERGYCOAT		},
+   {	"aspersio",				SC_ASPERSIO			},
+   {	"autoguard",			SC_AUTOGUARD		},
+   {	"reflectshield",		SC_REFLECTSHIELD	},
+   {	"endure",				SC_ENDURE			},
+   {	"defender",				SC_DEFENDER			},
+   {    "kaizel",				SC_KAIZEL			},
+   {    "kaahi",				SC_KAAHI			},
+   {    "kaupe",				SC_KAUPE			},
+   {    "eswoo",				SC_SWOO				},
+   {    "eska",				SC_SKA				},
+   {    "parry",				SC_PARRYING		    },
+   {    "berserk",				SC_ASPDPOTION3      },
+   {    "eske",				SC_SKE			    },
+   {    "soul",				SC_NEN			    },
+   {    "cicada",				SC_UTSUSEMI         }
+};
+
+const std::unordered_map<std::string, cell_chk> um_cellname2cellid{ // Subset used for mob ai
+	{    "cellwater",			CELL_CHKWATER},
+	{    "basilica",			CELL_CHKBASILICA},
+	{    "landprotector",		CELL_CHKLANDPROTECTOR},
+	{    "maelstrom",			CELL_CHKMAELSTROM},
+	{    "icewall",				CELL_CHKICEWALL},
+};
+
+
+const std::unordered_map<std::string, e_mob_skill_target> skill_target_name2enumid{
+		{	"target",	MST_TARGET	},
+		{	"randomtarget",	MST_RANDOM	},
+		{	"self",		MST_SELF	},
+		{	"friend",	MST_FRIEND	},
+		{	"master",	MST_MASTER	},
+		{	"around5",	MST_AROUND5	},
+		{	"around6",	MST_AROUND6	},
+		{	"around7",	MST_AROUND7	},
+		{	"around8",	MST_AROUND8	},
+		{	"around1",	MST_AROUND1	},
+		{	"around2",	MST_AROUND2	},
+		{	"around3",	MST_AROUND3	},
+		{	"around4",	MST_AROUND4	},
+		{	"around",	MST_AROUND	},
+};
+
+const std::unordered_map<std::string, e_mob_skill_condition> mob_skill_condition2name{
+	// enum e_mob_skill_condition
+	{ "always",             MSC_ALWAYS             },
+	{ "myhpltmaxrate",      MSC_MYHPLTMAXRATE      },
+	{ "myhpinrate",         MSC_MYHPINRATE         },
+	{ "friendhpltmaxrate",  MSC_FRIENDHPLTMAXRATE  },
+	{ "friendhpinrate",     MSC_FRIENDHPINRATE     },
+	{ "mystatuson",         MSC_MYSTATUSON         },
+	{ "mystatusoff",        MSC_MYSTATUSOFF        },
+	{ "masterstatuson",     MSC_MASTERSTATUSON     },
+	{ "masterstatusoff",     MSC_MASTERSTATUSOFF     },
+	{ "friendstatuson",     MSC_FRIENDSTATUSON     },
+	{ "friendstatusoff",    MSC_FRIENDSTATUSOFF    },
+	{ "enemystatuson",      MSC_ENEMYSTATUSON      },
+	{ "enemystatusoff",	    MSC_ENEMYSTATUSOFF     },
+	{ "attackpcgt",         MSC_ATTACKPCGT         },
+	{ "attackpcge",         MSC_ATTACKPCGE         },
+	{ "slavelt",            MSC_SLAVELT            },
+	{ "slavele",            MSC_SLAVELE            },
+	{ "closedattacked",     MSC_CLOSEDATTACKED     },
+	{ "longrangeattacked",  MSC_LONGRANGEATTACKED  },
+	{ "skillused",          MSC_SKILLUSED          },
+	{ "afterskill",         MSC_AFTERSKILL         },
+	{ "casttargeted",       MSC_CASTTARGETED       },
+	{ "rudeattacked",       MSC_RUDEATTACKED       },
+	{ "masterhpltmaxrate",  MSC_MASTERHPLTMAXRATE  },
+	{ "masterattacked",     MSC_MASTERATTACKED     },
+	{ "alchemist",          MSC_ALCHEMIST          },
+	{ "onspawn",            MSC_SPAWN              },
+	{ "expanded",			MSC_EXPANDED  }
+};
+
+const std::unordered_map<std::string, MobSkillState> um_mobskillstatename2id{
+		{	"any",		MSS_ANY		}, //All states except Dead
+		{	"idle",		MSS_IDLE	},
+		{	"walk",		MSS_WALK	},
+		{	"loot",		MSS_LOOT	},
+		{	"dead",		MSS_DEAD	},
+		{	"attack",	MSS_BERSERK	}, //Retaliating attack
+		{	"angry",	MSS_ANGRY	}, //Preemptive attack (aggressive mobs)
+		{	"chase",	MSS_RUSH	}, //Chase escaping target
+		{	"follow",	MSS_FOLLOW	}, //Preemptive chase (aggressive mobs)
+		{	"anytarget",MSS_ANYTARGET	}, //Berserk+Angry+Rush+Follow
+};
@@ -3641 +3759 @@ int mob_getfriendstatus_sub(struct block_list *bl,va_list ap)
-	ConditionLooperBase* cond_looper = va_arg(ap, ConditionLooperBase*);
+	expanded_ai::ConditionLooper* cond_looper=va_arg(ap, expanded_ai::ConditionLooper*);
@@ -3656 +3774 @@ int mob_getfriendstatus_sub(struct block_list *bl,va_list ap)
-struct block_list *mob_getfriendstatus(struct mob_data *md,ConditionLooperBase* cond_looper)
+struct block_list *mob_getfriendstatus(struct mob_data *md, expanded_ai::ConditionLooper* cond_looper)
@@ -3665 +3783 @@ struct block_list *mob_getfriendstatus(struct mob_data *md,ConditionLooperBase*
-bool ConditionLooperClassic::get_status(block_list* target) {
+bool expanded_ai::ConditionLooperClassic::get_status(block_list* target) {
@@ -3678 +3796 @@ bool ConditionLooperClassic::get_status(block_list* target) {
-	return flag ^ (this->cond1test);
+	return flag ^ (this->invertResult);
@@ -3681 +3799 @@ bool ConditionLooperClassic::get_status(block_list* target) {
-bool ConditionLooperExtended::get_status(block_list* bl) {
+bool expanded_ai::ConditionLooperExpanded::get_status(block_list* bl) {
@@ -3683 +3801 @@ bool ConditionLooperExtended::get_status(block_list* bl) {
-	return this->gc->test(this->targets); // Starts the big loop amongst expanded conditions
+	return this->CTcontainer->test(this->targets); // Starts the big loop amongst expanded conditions
@@ -3719,2 +3838,2 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-	if ((fbl = map_id2bl(md->master_id)) != NULL)
-		targets[MST_MASTER] = map_id2bl(md->master_id);
+	if ((mbl=map_id2bl(md->master_id)) != NULL)
+		targets[MST_MASTER]=mbl;
@@ -3734 +3853,3 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-		int c2, flag = 0;
+		int flag=0;
+		int c2 =ms[i]->cond2;
+			
@@ -3766 +3886,0 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-					c2 = stoi(ms[i]->cond2);
@@ -3771 +3890,0 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-					c2 = stoi(ms[i]->cond2);
@@ -3777,2 +3896 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-					c2 = stoi(ms[i]->cond2);
-					flag=ConditionLooperClassic(ms[i]->cond1 == MSC_MYSTATUSOFF,c2).get_status(targets[MST_SELF]);
+				flag=expanded_ai::ConditionLooperClassic(ms[i]->cond1 == MSC_MYSTATUSOFF, c2).get_status(targets[MST_SELF]);
@@ -3781 +3898,0 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-					c2 = stoi(ms[i]->cond2);
@@ -3784 +3900,0 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-					c2 = stoi(ms[i]->cond2);
@@ -3788,2 +3904 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-					c2 = stoi(ms[i]->cond2);
-					flag = ((fbl = mob_getfriendstatus(md,&ConditionLooperClassic(ms[i]->cond1 == MSC_FRIENDSTATUSOFF,c2))) != NULL);
+				flag=((fbl=mob_getfriendstatus(md, &expanded_ai::ConditionLooperClassic(ms[i]->cond1 == MSC_FRIENDSTATUSOFF, c2))) != NULL);
@@ -3793 +3907,0 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-					c2 = stoi(ms[i]->cond2);
@@ -3800,3 +3914,2 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-						flag=ConditionLooperClassic(ms[i]->cond1 == MSC_ENEMYSTATUSOFF,c2).get_status(bl);
-					}
-					else
+					flag=expanded_ai::ConditionLooperClassic(ms[i]->cond1 == MSC_ENEMYSTATUSOFF, c2).get_status(bl);
+				} else
@@ -3806 +3918,0 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-					c2 = stoi(ms[i]->cond2);
@@ -3809 +3920,0 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-					c2 = stoi(ms[i]->cond2);
@@ -3812 +3922,0 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-					c2 = stoi(ms[i]->cond2);
@@ -3815 +3924,0 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-					c2 = stoi(ms[i]->cond2);
@@ -3818 +3926,0 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-					c2 = stoi(ms[i]->cond2);
@@ -3825,2 +3933,8 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-					c2 = stoi(ms[i]->cond2);
-					flag = ((fbl = mob_getmasterhpltmaxrate(md, c2)) != NULL); break;
+				flag=((mbl=mob_getmasterhpltmaxrate(md, c2)) != NULL); break;
+			case MSC_MASTERSTATUSON:	// friend status[num] on
+			case MSC_MASTERSTATUSOFF:	// friend status[num] off
+				if (mbl != NULL)
+					flag=expanded_ai::ConditionLooperClassic(ms[i]->cond1 == MSC_MASTERSTATUSOFF, c2).get_status(mbl);
+				else
+					flag=0;
+				break;
@@ -3828 +3942 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-					flag = (md->master_id > 0 && (fbl=map_id2bl(md->master_id)) && unit_counttargeted(fbl) > 0); break;
+				flag=(md->master_id >0&& (mbl=map_id2bl(md->master_id)) && unit_counttargeted(mbl) > 0); break;
@@ -3832 +3946 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-				case MSC_EXTENDEDCONDITION:
+			case MSC_EXPANDED:
@@ -3834,2 +3948,2 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-						std::shared_ptr<GC> condition_composite;
-						if ((condition_composite = mob_extended_ai_conditions_db.find(ms[i]->cond2)) != nullptr) {
+				std::shared_ptr<expanded_ai::ConditionTesterContainer<block_list>> condition_container;
+				if ((condition_container=mob_expanded_ai_conditions_db.find(ms[i]->literal_cond2)) != nullptr) {
@@ -3838 +3952 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-								flag = ((fbl = mob_getfriendstatus(md, &ConditionLooperExtended(condition_composite, targets))) != NULL);
+						flag=((fbl=mob_getfriendstatus(md, &expanded_ai::ConditionLooperExpanded(condition_container, targets))) != NULL);
@@ -3841 +3955 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-								if (map_id2bl(md->master_id) == NULL)
+						if (mbl == NULL)
@@ -3843 +3957 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-								flag = condition_composite->test(targets);
+						flag=condition_container->test(targets);
@@ -3851 +3965 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-								flag = condition_composite->test(targets);
+						flag=condition_container->test(targets);
@@ -3854,3 +3968,2 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-						}
-						else {
-							ShowError("mob skill db : Invalid extended condition group [%s] for skill [%d]\n", ms[i]->cond2, ms[i]->skill_id);
+				} else {
+					ShowError("mob_skill_db:Invalid expanded condition '%s' for mobid %d skill %d-removing from db\n", ms[i]->literal_cond2, md->mob_id, ms[i]->skill_id);
@@ -3884 +3996,0 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-					bl = &md->bl;
@@ -3886,2 +3998,3 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-						bl = map_id2bl(md->master_id);
-					if (bl) //Otherwise, fall through.
+					bl=(mbl ? mbl:map_id2bl(md->master_id));
+				if (!bl)
+					continue;
@@ -3926 +4038,0 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-					bl = &md->bl;
@@ -3928,2 +4040,3 @@ int mobskill_use(struct mob_data *md, t_tick tick, int event)
-						bl = (bl ? bl : map_id2bl(md->master_id));
-					if (bl) //Otherwise, fall through.
+					bl=(mbl ? mbl:map_id2bl(md->master_id));
+				if (!bl) //Otherwise, fall through.
+					continue;
@@ -4151 +4264 @@ int mob_clone_spawn(struct map_session_data *sd, int16 m, int16 x, int16 y, cons
-					ms->cond2 = "95";
+					ms->cond2=95;
@@ -4165 +4278 @@ int mob_clone_spawn(struct map_session_data *sd, int16 m, int16 x, int16 y, cons
-					ms->cond2 = "90";
+					ms->cond2=90;
@@ -4175 +4288 @@ int mob_clone_spawn(struct map_session_data *sd, int16 m, int16 x, int16 y, cons
-				ms->cond2 = "90";
+				ms->cond2=90;
@@ -4179 +4292 @@ int mob_clone_spawn(struct map_session_data *sd, int16 m, int16 x, int16 y, cons
-					ms->cond2 = "1";
+					ms->cond2=1;
@@ -5714,25 +5827,2 @@ uint64 MobSummonDatabase::parseBodyNode(const YAML::Node &node) {
-
-
-
-template <class T>
-bool UC<T>::test(const std::map<short, block_list*>& targets) {
-	return t(targets);
-
-}
-bool GC::test(const std::map<short, block_list*>& targets) {
-	for (const std::shared_ptr<EC>& cond : this->conds) {
-		if (!this->isUnion && !cond->test(targets)) { // since we are in an AND, as soon as a condition is false return
-			return false;
-		}
-		if (this->isUnion && cond->test(targets)) //  we are in a OR, as soon as a condition is true return 
-			return true;
-	}
-	return !this->isUnion;    //False if union since not a single true condition was in the loop
-}
-
-
-void GC::push_back(std::shared_ptr<EC> ec) {
-	this->conds.push_back(ec);
-}
-namespace aexmod {
-	using std::string;
+namespace expanded_ai {
+	using namespace std;
@@ -5740,16 +5830,6 @@ namespace aexmod {
-	using std::shared_ptr;
-	using std::vector;
-	using std::map;
-	using std::make_shared;
-	using std::greater_equal;
-	using ai_functor_t = std::function<bool(std::map<short, block_list*>)>;
-	using ai_comparator_t = std::function<bool(int, int)>;
-	using ai_excluder_t = std::function<bool(bool)>;
-
-	bool isExclusion(bool exclude, bool flag) {
-		if (exclude)
-			flag = !flag;
-		return flag;
-	}
-
-	std::pair<ai_comparator_t, int> value_comp(string v) {
+	using predicate_t=std::function<bool(std::map<short, block_list*>)>;
+	using comparator_t=std::function<bool(int, int)>;
+	using inverter_t=std::function<bool(bool)>;
+
+	namespace {
+		pair<comparator_t, int> getComparatorAndValue(string v) {
@@ -5757 +5837 @@ namespace aexmod {
-		std::pair<ai_comparator_t, int> p;
+			std::pair<comparator_t, int> cvpair;
@@ -5763,3 +5843,2 @@ namespace aexmod {
-				p = std::pair<ai_comparator_t, int>(std::greater_equal<int>(), value);
-			}
-			else {
+					cvpair=std::pair<comparator_t, int>(std::greater_equal<int>(), value);
+				} else {
@@ -5767,2 +5846 @@ namespace aexmod {
-				p = std::pair<ai_comparator_t, int>(std::greater<int>(), value);
-			}
+					cvpair=std::pair<comparator_t, int>(std::greater<int>(), value);
@@ -5770 +5848 @@ namespace aexmod {
-		else if (v[0] == '<') {
+			} else if (v[0] == '<') {
@@ -5773,3 +5851,2 @@ namespace aexmod {
-				p = std::pair<ai_comparator_t, int>(std::less_equal<int>(), value);
-			}
-			else {
+					cvpair=std::pair<comparator_t, int>(std::less_equal<int>(), value);
+				} else {
@@ -5777 +5854 @@ namespace aexmod {
-				p = std::pair<ai_comparator_t, int>(std::less<int>(), value);
+					cvpair=std::pair<comparator_t, int>(std::less<int>(), value);
@@ -5780,4 +5862,0 @@ namespace aexmod {
-		else if (v[0] == '=') {
-			value = stoi(v.substr(0, valueEndPos));
-			p = std::pair<ai_comparator_t, int>(std::equal_to<int>(), value);
-		}
@@ -5785 +5864,3 @@ namespace aexmod {
-		return p;
+			return cvpair;
+
+
@@ -5789,2 +5869,0 @@ namespace aexmod {
-		ai_functor_t functor;
-
@@ -5804,3 +5919,4 @@ namespace aexmod {
-	ai_functor_t getFunctor(string line) {
-		ai_excluder_t excluder;
-		ai_comparator_t comparator;
+	predicate_t createPredicate(const string& line) {
+
+		inverter_t inverter;
+		comparator_t comparator;
@@ -5809,2 +5925,3 @@ namespace aexmod {
-		if (container.size() > 4) {
-			ShowError("mob_expanded_conditions_db: line with %d words in %s \n", container.size(), line.c_str());
+		if (container.size() >4|| container.size()<2) {
+			ShowError("mob_expanded_conditions_db: line with %d words in '%s' \n", container.size(), line.c_str());
+			return nullptr;
@@ -5815 +5932,5 @@ namespace aexmod {
-			excluder = [](bool result) {return !result;};
+			inverter=[](bool result) {return !result;};
+		} else {
+			if (container.size() == 4) {
+				ShowError("mob_expanded_conditions_db: syntax error in '%s', correct format is 'target [not] test [[><[=]]value]' \n", line.c_str());
+				return nullptr;
@@ -5817,2 +5938,3 @@ namespace aexmod {
-		else
-			excluder = [](bool result) {return result;};
+			inverter=[](bool result) {return result;};
+		}
+
@@ -5820,2 +5942 @@ namespace aexmod {
-		std::string value_str;
-		std::pair<ai_comparator_t, int> p;
+		std::pair<comparator_t, int> comparatorValuePair;
@@ -5824,4 +5945,2 @@ namespace aexmod {
-			value_str = container[2];
-			p = value_comp(value_str);
-			value = p.second;
-			comparator = p.first;
+			try {
+				comparatorValuePair=getComparatorAndValue(container[2]);
@@ -5829 +5948,7 @@ namespace aexmod {
-		else
+			catch (const std::invalid_argument& ia) {
+				ShowError("mob_expanded_conditions_db: '%s' in line '%s' \n", ia.what(), line.c_str());
+				return nullptr;
+			}
+			value=comparatorValuePair.second;
+			comparator=comparatorValuePair.first;
+		} else{
@@ -5831,5 +5956 @@ namespace aexmod {
-		short target = ai_target_map.at(target_str);
-		ai_functor_t functor;
-		int element = 0;
-		if (field == "percenthealth") {
-			functor = ai_percenthealth<ai_excluder_t, ai_comparator_t>(excluder, target, comparator, value);
+			comparator=std::greater<int>();
@@ -5837,5 +5958,4 @@ namespace aexmod {
-		else if (field == "health")
-			functor = ai_health<ai_excluder_t, ai_comparator_t>(excluder, target, comparator, value);
-		else if (ai_cell_map.count(field)) {
-			value = ai_cell_map.at(field);
-			functor = ai_cellcheck<ai_excluder_t>(excluder, target, value);
+			
+		short target;
+		try {
+			target=skill_target_name2enumid.at(target_str);
@@ -5843,2 +5963,14 @@ namespace aexmod {
-		else if (field == "job")
-			functor = ai_job<ai_excluder_t, ai_comparator_t>(excluder, target, comparator, value);
+		catch (const std::out_of_range& ia) {
+			ShowError("mob_expanded_conditions_db: wrong target %s in line '%s' \n", target_str, line.c_str());
+			return nullptr;
+		}
+
+		if (field == "percenthealth") {
+			return  predicates::percent_health<inverter_t, comparator_t>(inverter, target, comparator, value);
+		} else if (field == "health")
+			return  predicates::health<inverter_t, comparator_t>(inverter, target, comparator, value);
+		else if (um_cellname2cellid.count(field)) {
+			value=um_cellname2cellid.at(field);
+			return  predicates::cell<inverter_t>(inverter, target, static_cast<cell_chk>(value));
+		} else if (field == "job")
+			return  predicates::job<inverter_t, comparator_t>(inverter, target, comparator, value);
@@ -5846 +5978 @@ namespace aexmod {
-			functor = ai_attackrange<ai_excluder_t, ai_comparator_t>(excluder, target, comparator, value);
+			return  predicates::attack_range<inverter_t, comparator_t>(inverter, target, comparator, value);
@@ -5848,8 +5980,13 @@ namespace aexmod {
-			functor = ai_distance<ai_excluder_t, ai_comparator_t>(excluder, target, comparator, value);
-		else if (field == "distance2")
-			functor = ai_dally<ai_excluder_t, ai_comparator_t>(excluder, target, comparator, value);
-		else if (ai_status_map.count(field)) {  // status
-			value = ai_status_map.at(field);
-			functor = ai_status<ai_excluder_t>(excluder, target, value); // level
-	   	}	
-		else if (fillWithElement(element, field)) {// modifies values
+			return  predicates::target_distance<inverter_t, comparator_t>(inverter, target, comparator, value);
+		else if (field == "target_distance_ally")
+			return  predicates::target_distance_from_ally<inverter_t, comparator_t>(inverter, target, comparator, value);
+		else if (field == "target_distance_master")
+			return  predicates::target_distance_from_master<inverter_t, comparator_t>(inverter, target, comparator, value);
+		else if (um_statusname2id.count(field)) {  // status
+			value=um_statusname2id.at(field);
+			return  predicates::status<inverter_t>(inverter, target, value);
+		} else if (field == "reflectphy")
+			return  predicates::physical_reflect<inverter_t, comparator_t>(inverter, target, comparator, value);
+		else {
+			int element=0;
+			if (fillWithElement(element, field)) {// modifies parameters
@@ -5857 +5994 @@ namespace aexmod {
-				functor = ai_elementarmor<ai_excluder_t, ai_comparator_t>(excluder, target, comparator, element, value); // level
+					return  predicates::element_armor<inverter_t, comparator_t>(inverter, target, comparator, element, value);
@@ -5859 +5996 @@ namespace aexmod {
-				functor = ai_elementattack<ai_excluder_t>(excluder, target, element);
+					return  predicates::element_attack<inverter_t>(inverter, target, element);
@@ -5861 +5998 @@ namespace aexmod {
-				functor = ai_elementresist<ai_excluder_t, ai_comparator_t>(excluder, target, comparator, element, value);
+					return  predicates::element_resist<inverter_t, comparator_t>(inverter, target, comparator, element, value);
@@ -5863,3 +5999,0 @@ namespace aexmod {
-		else {
-			functor = ai_functor<ai_excluder_t>();
-			ShowError("mob_expanded_conditions_db: '%s' is invalid \n", line.c_str());
@@ -5868 +6003,0 @@ namespace aexmod {
-		return functor;
@@ -5870 +6005,3 @@ namespace aexmod {
-	std::shared_ptr<EC> createEC(const Node& node) {
+	std::shared_ptr<ConditionNode<block_list>> createConditionNode(const Node& node) {
+		using pConditionNode_t=shared_ptr<ConditionNode<block_list>>;
+		using pConditionNode_iterator_t=typename vector<pConditionNode_t>::const_iterator;
@@ -5872 +6008,0 @@ namespace aexmod {
-		shared_ptr<GC> gc = make_shared<GC>();
@@ -5874,27 +6010,21 @@ namespace aexmod {
-			if (node["or"]) {
-				gc->isUnion = true;
-			}
-			else if (node["and"]) {
-				gc->isUnion = false;
-			}
-			else if (node["composite"]) {
-				gc = mob_extended_ai_conditions_db.find(node["composite"].as<string>());
-				return gc;
-			}
-			const auto seq = node.begin();
-			const auto& seq_conds = seq->second.as<Node>();
-			for (size_t i = 0;i < seq_conds.size();i++) {
-				shared_ptr<EC> pec = createEC(seq_conds[i]);
-				gc->push_back(pec);
-			}
-			return gc;
-		}
-		else {
-		
-			//Start the big filling
-			string condition_str = node.as<string>();
-			
-			ai_functor_t functor = getFunctor(condition_str);
-			return std::make_shared<UC<ai_functor_t>>(functor);		
-		}
-	}
+			const auto& pair=node.begin();// there is only one pair per map
+			const string key=pair->first.as<string>();
+			shared_ptr<ConditionTesterContainer<block_list>> pContainer=make_shared<ConditionTesterContainer<block_list>>();
+			if (key == "or") {
+				pContainer->logicFunction=std::any_of<pConditionNode_iterator_t, std::function<bool(pConditionNode_t)>>;
+			} else if (key == "and") {
+				pContainer->logicFunction=std::all_of<pConditionNode_iterator_t, std::function<bool(pConditionNode_t)>>;
+			} else if (key == "nand") {
+				pContainer->logicFunction=any_false_of<pConditionNode_iterator_t, std::function<bool(pConditionNode_t)>>;
+			} else if (key == "nor") {
+				pContainer->logicFunction=std::none_of<pConditionNode_iterator_t, std::function<bool(pConditionNode_t)>>;
+			} else if (key == "xor") {
+				pContainer->logicFunction=one_only<pConditionNode_iterator_t, std::function<bool(pConditionNode_t)>>;
+			} else if (key == "nxor") {
+				pContainer->logicFunction=all_or_none<pConditionNode_iterator_t, std::function<bool(pConditionNode_t)>>;
+			} else {
+				shared_ptr<ConditionTesterContainer<block_list>> stored_container;
+				stored_container=mob_expanded_ai_conditions_db.find(node.begin()->second.as<string>());
+				if (stored_container == nullptr) {
+					ShowError("mob_expanded_ai_conditions:invalid line around word '%s'\n", key.c_str());
+					return nullptr;
@@ -5902,8 +6032,5 @@ namespace aexmod {
-template <typename Container>
-void split(const std::string& str, Container& cont, char delim) {
-	std::size_t current, previous = 0;
-	current = str.find(delim);
-	while (current != std::string::npos) {
-		cont.push_back(str.substr(previous, current - previous));
-		previous = current + 1;
-		current = str.find(delim, previous);
+				if (key == "not")
+					stored_container->isToInvert=true;
+				else
+					stored_container->isToInvert=false;
+				return stored_container;
@@ -5911 +6038,9 @@ void split(const std::string& str, Container& cont, char delim) {
-	cont.push_back(str.substr(previous, current - previous));
+			const auto& sequence=pair->second.as<Node>();
+			loop_and_push(sequence, pContainer);
+			return pContainer;
+		} else {
+			predicate_t conditionTesterPredicate=createPredicate(node.as<string>());
+			shared_ptr<ConditionTester<block_list, predicate_t>> pCondition_tester;
+			if (conditionTesterPredicate != nullptr)
+				pCondition_tester=std::make_shared<ConditionTester<block_list, predicate_t>>(conditionTesterPredicate);
+			return pCondition_tester;
@@ -5913,11 +6047,0 @@ void split(const std::string& str, Container& cont, char delim) {
-
-uint64 MobExtendedAiConditionsDatabase::parseBodyNode(const YAML::Node &node) {
-	std::string entry_name;
-	const auto entry = node.begin();
-	entry_name = entry->first.as<std::string>();
-	const auto& entry_conds = entry->second.as<YAML::Node>();
-	std::shared_ptr<GC> first_gc = std::make_shared<GC>();							//adds the first conds or group conds under a first implicit "and"
-	first_gc->isUnion = false;
-	for (size_t i = 0;i < entry_conds.size();i++) {
-		std::shared_ptr<EC> pec = aexmod::createEC(entry_conds[i]);
-		first_gc->push_back(pec);
@@ -5925,4 +6048,0 @@ uint64 MobExtendedAiConditionsDatabase::parseBodyNode(const YAML::Node &node) {
-	//add first_gc to allow composite conditions
-	
-	mob_extended_ai_conditions_db.put(entry_name, first_gc);
-	return 1;
@@ -5931,4 +6050,0 @@ uint64 MobExtendedAiConditionsDatabase::parseBodyNode(const YAML::Node &node) {
-
-const std::string MobExtendedAiConditionsDatabase::getDefaultLocation() {
-	return std::string(db_path) + "/mob_extended_ai_conditions_db.yml";
-}
@@ -5936 +6052 @@ const std::string MobExtendedAiConditionsDatabase::getDefaultLocation() {
- * Reads and parses an entry from the mob_extended_ai_conditions_db.
+*Reads and parses an entry from the mob_expanded_ai_conditions_db.
@@ -5940 +6056 @@ const std::string MobExtendedAiConditionsDatabase::getDefaultLocation() {
-/*uint64 parseBodyNode2(const Node &node) {
+uint64 MobExpandedAiConditionsDatabase::parseBodyNode(const YAML::Node &node) {
@@ -5942,3 +6058,2 @@ const std::string MobExtendedAiConditionsDatabase::getDefaultLocation() {
-	for (const auto& pair : node) {
-		shared_ptr<vector<s_mob_extended_ai_condition>> ai_ext_conditions = make_shared<vector<s_mob_extended_ai_condition>>();
-		string ai_ext_cond_entry_name = pair.first.as<string>(); 
+	const auto entry=node.begin(); // All expanded conditions are single element maps, so we just have to use begin() to get that only pair.
+	const std::string& expanded_condition_name=entry->first.as<std::string>();
@@ -5946,4 +6061,7 @@ const std::string MobExtendedAiConditionsDatabase::getDefaultLocation() {
-		for (const auto& targets : pair.second ){ //"target","self","ally"
-			for (const auto& conds : targets.second) {
-				s_mob_extended_ai_condition ai_cond;
-				ai_cond.fcn_arg_target = targets.first.as<string>();
+	// sequence of strings and maps
+	const auto& first_seq_of_conditions=entry->second.as<YAML::Node>();
+	// Main condition testers container.
+	std::shared_ptr<expanded_ai::ConditionTesterContainer<block_list>> main_container=std::make_shared<expanded_ai::ConditionTesterContainer<block_list>>();
+	//adds the first inner conditions under a first implicit "and"
+	using pConditionNode_t=std::shared_ptr<expanded_ai::ConditionNode<block_list>>;
+	using pConditionNode_iterator_t=typename std::vector<pConditionNode_t>::const_iterator;
@@ -5951,14 +6069,3 @@ const std::string MobExtendedAiConditionsDatabase::getDefaultLocation() {
-				//loop through conditions
-				if(conds.second.Type()!=YAML::NodeType::Map) { 
-					ai_cond.fcn_arg_exclude = false;
-					ai_extended_condition_functions::fill_condition_and_push(conds.first.as<string>(),conds.second.as<string>(), ai_cond,ai_ext_conditions);
-				}
-				//Enter excluded conditions node
-				else {
-					ai_cond.fcn_arg_exclude = true;
-					//loop through excluded conditions
-					for (const auto& excludedConds : conds.second) 
-						ai_extended_condition_functions::fill_condition_and_push(excludedConds.first.as<string>(), excludedConds.second.as<std::string>(), ai_cond,ai_ext_conditions);									
-				}		
-			}
-		}
+	main_container->logicFunction=std::all_of<pConditionNode_iterator_t, std::function<bool(pConditionNode_t)>>;
+	expanded_ai::loop_and_push(first_seq_of_conditions, main_container);
+	//add first_gc to allow composite conditions
@@ -5966 +6073,3 @@ const std::string MobExtendedAiConditionsDatabase::getDefaultLocation() {
-		//mob_extended_ai_conditions_db.put(ai_ext_cond_entry_name, ai_ext_conditions);
+	mob_expanded_ai_conditions_db.put(expanded_condition_name, main_container);
+	return 1;
+}
@@ -5969,2 +6080 @@ const std::string MobExtendedAiConditionsDatabase::getDefaultLocation() {
-	return 1;
-}*/
+
@@ -6078,4 +6188,2 @@ static bool mob_parse_row_mobskilldb(char** str, int columns, int current)
-	const std::map<std::string, MobSkillState>& state = ai_skillstate_map;
-	const std::map<std::string, MobSkillState>::const_iterator it = state.find(str_state);
-	if (it!=state.end())
-		ms->state = it->second;
+	if (um_mobskillstatename2id.count(str_state))
+		ms->state=um_mobskillstatename2id.at(str_state);
@@ -6124,5 +6232,3 @@ static bool mob_parse_row_mobskilldb(char** str, int columns, int current)
-	const std::string& str_target = str[9];
-	const std::map<std::string, e_mob_skill_target>& target = ai_target_map;
-	const auto& it_target = target.find(str_target);
-	if (it_target!=target.end())
-		ms->target = it_target->second;
+	const std::string& target_str=str[9];
+	if (skill_target_name2enumid.count(target_str))
+		ms->target=skill_target_name2enumid.at(target_str);
@@ -6130 +6236 @@ static bool mob_parse_row_mobskilldb(char** str, int columns, int current)
-		ShowWarning("mob_parse_row_mobskilldb: Unrecognized target %s for %d\n", str_target, mob_id);
+		ShowWarning("mob_parse_row_mobskilldb: Unrecognized target %s for %d\n", target_str, mob_id);
@@ -6153,4 +6259,2 @@ static bool mob_parse_row_mobskilldb(char** str, int columns, int current)
-	const std::map <std::string, e_mob_skill_condition>& cond1 = ai_skillcondition_map;
-	const auto& it_cond = cond1.find(str_cond);
-	if (it_cond!=cond1.end())
-		ms->cond1 = it_cond->second;
+	if (mob_skill_condition2name.count(str_cond))
+		ms->cond1=mob_skill_condition2name.at(str_cond);
@@ -6163,2 +6266,0 @@ static bool mob_parse_row_mobskilldb(char** str, int columns, int current)
-	
-
@@ -6167,5 +6269,17 @@ static bool mob_parse_row_mobskilldb(char** str, int columns, int current)
-	const auto& it_cond2 = ai_status_map.find(str_cond2);
-	if (it_cond2 != ai_status_map.end())
-		ms->cond2 = std::to_string(it_cond2->second);
-	else
-		ms->cond2 = str_cond2;
+
+	if(str_cond2 == "")
+		ms->cond2=0;
+	else if (um_statusname2id.count(str_cond2)) {
+		ms->cond2=um_statusname2id.at(str_cond2);
+	} else if (mob_expanded_ai_conditions_db.find(str_cond2) != nullptr)
+		ms->literal_cond2=str_cond2;
+	else{
+		try{
+			ms->cond2=stoi(str_cond2);
+		} catch(std::invalid_argument ia){
+			ShowWarning("mob_parse_row_mobskilldb: Unrecognized condition2%s for %d\n", str_cond2, mob_id);
+			return false;
+		}
+	}
+	ms->literal_cond2=str_cond2; // For error message if calling ill-formed expanded condition
+
@@ -6617 +6731 @@ static void mob_load(void)
-
+	mob_expanded_ai_conditions_db.load(); // load before mob_skill_db
@@ -6645,2 +6758,0 @@ static void mob_load(void)
-	mob_extended_ai_conditions_db.load();
-	
@@ -6813 +6925 @@ void do_final_mob(bool is_reload){
-	mob_extended_ai_conditions_db.clear();
+	mob_expanded_ai_conditions_db.clear();
